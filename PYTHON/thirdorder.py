#!/usr/bin/python
# -*- coding: utf-8 -*-
#  thirdorder, help compute anharmonic IFCs from minimal sets of displacements
#  Copyright (C) 2012-2013 Wu Li <wu.li@cea.fr>
#  Copyright (C) 2012-2013 Jesús Carrete Montaña <jcarrete@gmail.com>
#  Copyright (C) 2012-2013 Natalio Mingo Bisquert <natalio.mingo@cea.fr>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import os.path
import copy
import glob
import numpy
import scipy
import scipy.linalg
import spg
import common

H=2.116709e-3  # Magnitude of the finite displacements, in nm.

def move_two_atoms(poscar,iat,icoord,ih,jat,jcoord,jh):
    """
    Return a copy of poscar with atom iat displaced by ih nm along
    its icoord-th Cartesian coordinate and atom jat displaced by
    jh nm along its jcoord-th Cartesian coordinate.
    """
    nruter=copy.deepcopy(poscar)
    pos=numpy.dot(nruter["lattvec"],nruter["positions"][:,(iat,jat)])
    pos[icoord,0]+=ih
    pos[jcoord,1]+=jh
    nruter["positions"][:,(iat,jat)]=scipy.linalg.solve(
        nruter["lattvec"],pos)
    return nruter


def write_POSCAR(poscar,filename):
    """
    Write the contents of poscar to filename.
    """
    f=open(filename,"w")
    f.write("{}\n1.0\n".format(filename))
    for i in range(3):
        f.write("{0[0]:>20g} {0[1]:>20g} {0[2]:>20g}\n".format(
            (poscar["lattvec"][:,i]*10.).tolist()))
    f.write("{}\n".format(" ".join(poscar["elements"])))
    f.write("{}\n".format(" ".join([str(i) for i in poscar["numbers"]])))
    f.write("Direct\n")
    for i in range(poscar["positions"].shape[1]):
        f.write("{0[0]:>20g} {0[1]:>20g} {0[2]:>20g}\n".format(
            poscar["positions"][:,i].tolist()))
    f.close()


def normalize_SPOSCAR(sposcar,na,nb,nc):
    """
    Rearrange sposcar, as generated by common.gen_POSCAR, so that it
    is in valid VASP order, and return the result.
    """
    nruter=copy.deepcopy(sposcar)
    # Order used internally (from most to least significant):
    # k,j,i,iat For VASP, iat must be the most significant index,
    # i.e., atoms of the same element must go together.
    indices=numpy.array(range(nruter["positions"].shape[1])).reshape((nc,nb,na,-1))
    indices=numpy.rollaxis(indices,3,0).flatten().tolist()
    nruter["positions"]=nruter["positions"][:,indices]
    return nruter


if __name__=="__main__":
    if len(sys.argv) not in (5,6) or sys.argv[1] not in ("sow","reap"):
        sys.exit("Usage: {} sow|reap na nb nc [cutoff[nm]]".format(sys.argv[0]))
    action=sys.argv[1]
    na,nb,nc=[int(i) for i in sys.argv[2:5]]
    if len(sys.argv)==6:
        frange2=float(sys.argv[5])**2
    else:
        frange2=None
    poscar=common.read_POSCAR(".")
    symops=spg.SymmetryOperations(poscar["lattvec"],poscar["types"],
                                  poscar["positions"].T)
    print "Symmetry group {} detected".format(symops.symbol)
    wedgeres=common.wedge(poscar,symops,na,nb,nc,frange2)
    list4=common.build_list4(wedgeres)
    if action=="sow":
        sposcar=common.gen_SPOSCAR(poscar,na,nb,nc)
        width=len(str(4*(len(list4)+1)))
        namepattern="POSCAR-{{0:0{}d}}".format(width)
        for i,e in enumerate(list4):
            for n in range(4):
                isign=(-1)**(n%2)
                jsign=(-1)**(n//2)
                number=4*i+n+1
                dsposcar=normalize_SPOSCAR(
                    move_two_atoms(sposcar,
                                   e[0],e[2],isign*H,
                                   e[1],e[3],jsign*H),
                    na,nb,nc)
                filename=namepattern.format(number)
                write_POSCAR(dsposcar,filename)
    else:
        pass
